{
  "name": "Spring Data Mock",
  "tagline": "Mock facility for Spring Data repositories",
  "body": "# Spring Data Mock\r\n\r\nThis is a fairly flexible, versatile framework for mocking Spring Data repositories. Spring Data provides a very good\r\nfoundation for separating the concerns of managing a database and its subsequently resulting queries from those of the\r\nbusiness layer.\r\n\r\nThis is great for writing services. They only need to depend upon Spring Data repositories and manage their data through\r\nthis level of indirection. This, however, means that for testing purposes, you will either have to write lots of boilerplate\r\ncode for your Spring powered application, or you will have to start up a full blown application context with a backing\r\ndatabase.\r\n\r\nFor most test cases, this is entirely unnecessary and, moreover, creates time burdens and takes away valuable time from\r\nproductive tasks. This is why I decided to write this framework: to avoid the unnecessary effort, and to have a reliable\r\ninfrastructure replicating what Spring would do with an actual database, only in-memory. This will allow for mocking the\r\nrepository with actual data. Thus, you can test your services *without* having to start up the application context, and\r\nwith the highest level of isolation -- with actual data.\r\n\r\n## Downloading\r\n\r\nYou can either clone this project and start using it:\r\n\r\n    $ git clone https://github.com/mmnaseri/spring-data-mock.git\r\n\r\nor you can add a maven dependency since it is now available in Maven central:\r\n\r\n    <dependency>\r\n        <groupId>com.mmnaseri.utils</groupId>\r\n        <artifactId>spring-data-mock</artifactId>\r\n        <version>1.0</version>\r\n    </dependency>\r\n\r\n## Quick Start\r\n\r\nRegardless of how you add the necessary dependency to your project, mocking a repository can be as simple as:\r\n\r\n    final UserRepository repository = builder().mock(UserRepository.class);\r\n    \r\nwhere `builder()` is a static method of the `RepositoryFactoryBuilder` class under package `com.mmnaseri.utils.spring.data.dsl.factory`.\r\n\r\nAn alternate way of mocking a repository would be by using the `RepositoryMockBuilder` class under the `com.mmnaseri.utils.spring.data.dsl.mock`\r\npackage:\r\n\r\n    final RepositoryFactoryConfiguration configuration = ... ;\r\n    final UserRepository repository = new RepositoryMockBuilder().useConfiguration(configuration).mock(UserRepository.class);\r\n    \r\n## Mocking a Repository\r\n\r\nTo mock a repository you must somehow use the underlying `RepositoryFactory`. There is currently a single implementation of\r\nthis interface available, `com.mmnaseri.utils.spring.data.proxy.impl.DefaultRepositoryFactory`. The factory has a `getInstance(...)`\r\nmethod that let's you customize the mocking for each instance of the repository you create. This means that you can mock a\r\nsingle repository multiple times, each time with a different set of behaviors:\r\n\r\n    final UserRepository repository = factory.getInstance(keyGenerator, UserRepository.class, Implementation1.class, Implementation2.class);\r\n\r\nThere are three components to this method call:\r\n\r\n  1. The **key generator** (which can be `null`) will determine the strategy for generating keys for the ID field for\r\n  an entity when it is inserted into the underlying data store.\r\n  2. The **repository interface** which is the interface you want to instantiate and have proxied for you.\r\n  3. The **custom implementations** (which are optional) that can provide custom ways of handling repository method calls.\r\n  \r\nA minimal way of instantiating a repository would be:\r\n\r\n    final UserRepository repository = factory.getInstance(null, UserRepository.class);\r\n\r\nwhich disables automatic key generation, and relies solely on default implementations for handling method calls.\r\n\r\n### Repository Factory Configuration\r\n\r\nThe default repository factory implementation takes in a configuration object which will let you customize multiple\r\naspects of the mocking mechanism.\r\n\r\nThe configuration object allows you the following customizations:\r\n\r\n  * Change the way *repository metadata* is resolved from a given repository class object. The following metadata is\r\n  required to work with a repository and to be able to efficiently mock its intended behavior: 1) the entity type,\r\n  2) the type of the identifier 3) the property corresponding to the identifier\r\n  * Change the way a *query method name* is parsed and converted into a data filter object. By default, query methods\r\n  which follow the standard declared by Spring Data are parsed and honored. Additionally, the first word is taken as\r\n  a function and can thus be used to implement custom behavior. This is to enable extension in case of further support\r\n  by the Spring Data team. Also, the operators (such as \"Is Greater Than\", \"Is Equal To\", \"Is Between\", etc.) are customizable.\r\n  * Customize the set of available aggregate and operational *functions*.\r\n  * Customize the underlying *data store* mapping for each entity type. By default, storage is done in-memory. But there is\r\n  nothing preventing you from attaching the data store for a particular type of entity to another source. All you have to do\r\n  is to implement the `com.mmnaseri.utils.spring.data.store.DataStore` interface and add it to this context. It is actually\r\n  much easier than it sounds.\r\n  * Decide *how results should be adapted* from an actual value returned from implementation methods to the way a\r\n  repository method is supposed to return values. This is to allow, for instance, to implement a `findAll` method that\r\n  returns a collection of items, and then reuse its implementation for a repository method named `findAll` that is supposed\r\n  to return a set.\r\n  * Set *default implementations* for particular repository types and subtypes.\r\n  * Add and customize *event listeners* to data store actions. These can listen to events before and after inserting, updating,\r\n  and deleting a particular entity.\r\n\r\nSince the configuration object is complex and can be a hassle to create, you can use the much easier to use DSL via the\r\n`com.mmnaseri.utils.spring.data.dsl.factory.RepositoryFactoryBuilder` class. We will go over that shortly.\r\n\r\n### Using the DSL to Mock a Repository\r\n\r\nOnce you have a configuration object at hand, you can use the DSL bundled with this framework to easily mock\r\nyour repositories and avoid going through the RepositoryFactory class.\r\n\r\nYou can mock a repository this way:\r\n\r\n    final RepositoryMockBuilder builder = new RepositoryMockBuilder();\r\n    final UserRepository repository = builder.useConfiguration(configuration)\r\n        .generateKeysUsing(UUIDKeyGenerator.class) //***\r\n        .usingImplementation(SampleImpl1.class)\r\n            .and(SampleImpl2.class)\r\n            .and(SampleImpl3.class)\r\n        .mock(UserRepository.class);\r\n\r\nYou have to note that this builder is *stateless*, meaning that each of the methods in this builder will not modify an\r\ninternal state, but rather return an object which reflects all the configurations up to this point.\r\n\r\nThis is by design, and is to allow developers and testers the freedom of reusing their configurations.\r\n\r\n### Using the DSL to Create a Configuration\r\n\r\nWhereas mocking a repository is a relatively painless process and might not require the use of a dedicated DSL, creating\r\na configuration is another story altogether. In recognition of this fact, I have created a DSL for this very purpose, so\r\nthat you can craft configurations using a *stateful* builder via this DSL:\r\n\r\n    final RepositoryFactoryBuilder builder = RepositoryFactoryBuilder.builder()\r\n        .resolveMetadataUsing(...)\r\n        .registerOperator(...) //register some operator\r\n            .and(...).and(...) //register other operators\r\n        .registerFunction(...) //register data function\r\n            .and(...).and(...) //register additional data functions\r\n        .registerDataStore(...) //register a data store to be used in the configured repositories\r\n            .and(...).and(...) //register additional data stores\r\n        .adaptResultsUsing(...) //register a result adapter\r\n            .and(...).and(...) //register additional result adapters\r\n        .honoringImplementation(...) //add some custom implementation on a global scope\r\n            .and(...).and(...) //register additional implementations\r\n        .enableAuditing(...) //enable support for Spring Data's auditing and pass in a custom auditor aware instance\r\n        .withListener(...) //register some event listener\r\n            .and(...).and(...) //register additional event listeners\r\n\r\nAt this stage, you can either call to the `configure()` method on the builder object to get a configuration object, or\r\nyou can skip this step and continue from the key generation step of the mock builder (marked with three stars in the previous\r\nlisting).\r\n\r\nAll of the steps above are optional. All values have defaults and you can skip setting them and still expect everything\r\nto just work out of the box.\r\n\r\nTo answer the question of what all of these configurable steps mean, we need to go to the next section.\r\n\r\n### The Mechanics\r\n\r\nIn this section, we will detail the framework and go over how each part of it can be configured.\r\n\r\n#### Metadata Resolver\r\n\r\nThe metadata resolver is an entity that is capable of looking at a repository interface and figuring out detail about\r\nthe repository as well as the persistent entity it is supporting. This is what the metadata resolver will find out:\r\n\r\n  * the type of the entity for which the repository has been created\r\n  * the (either actual or encapsulated) property of the persistent entity which holds the identifier\r\n  * the type of the identifier associated with the entity\r\n\r\nThe default metadata resolver is the `com.mmnaseri.utils.spring.data.domain.impl.DefaultRepositoryMetadataResolver`\r\nclass, which will first see if the repository is annotated with `@org.springframework.data.repository.RepositoryDefinition`\r\nand if not tries to extract its metadata from the interface should it extend `org.springframework.data.repository.Repository`.\r\n\r\nIf none of these conditions are met, it will throw an exception.\r\n\r\n#### The Operators\r\n\r\nThe operators are what drive how the query methods are parsed. This is the general recipe:\r\n\r\nAt each juncture, we look for the operator whose tokens matches the longest suffix, and assume the rest to be a\r\nproperty path, so that for instance, if we are parsing \"ParentParentAgeGreaterThanEqual\", we will match it with the\r\noperator \"GreaterThanEqual\", and consider the \"ParentParentAge\" to be a property path (which might be `parent.parent.age`).\r\n\r\nEach operator has a `Matcher`, which will help identify whether or not based on a given criteria an entity instance matches\r\nthe query.\r\n\r\nBy extending the operators, you can practically extend the query method DSL. This might not be practical, as we might not want\r\nto support things that Spring Data doesn't support yet, but it allows for a better maintainability and easier extensibility should\r\nSpring Data actually expand beyond what it is today.\r\n\r\nBelow is a list of the default operators that ship with this framework:\r\n\r\n Operator                  | Suffixes\r\n---------------------------|---------------------------------------------------\r\nAFTER                      | `After`, `IsAfter`\r\nBEFORE                     | `Before`, `IsBefore`\r\nCONTAINING                 | `Containing`, `IsContaining`, `Contains`\r\nBETWEEN                    | `Between`, `IsBetween`\r\nNOT_BETWEEN                | `NotBetween`, `IsNotBetween`\r\nENDING_WITH                | `EndingWith`, `IsEndingWith`, `EndsWith`\r\nFALSE                      | `False`, `IsFalse`\r\nGREATER_THAN               | `GreaterThan`, `IsGreaterThan`\r\nGREATER_THAN_EQUALS        | `GreaterThanEqual`, `IsGreaterThanEqual`\r\nIN                         | `In`, `IsIn`\r\nIS                         | `Is`, `EqualTo`, `IsEqualTo`, `Equals`\r\nNOT_NULL                   | `NotNull`, `IsNotNull`\r\nNULL                       | `Null`, `IsNull`\r\nLESS_THAN                  | `LessThan`, `IsLessThan`\r\nLESS_THAN_EQUAL            | `LessThanEqual`, `IsLessThanEqual`\r\nLIKE                       | `Like`, `IsLike`\r\nNEAR                       | `Near`, `IsNear`\r\nNOT                        | `IsNot`, `Not`, `IsNotEqualTo`, `DoesNotEqual`\r\nNOT_IN                     | `NotIn`, `IsNotIn`\r\nNOT_LIKE                   | `NotLike`, `IsNotLike`\r\nREGEX                      | `Regex`, `MatchesRegex`, `Matches`\r\nSTARTING_WITH              | `StartingWith`, `IsStartingWith`, `StartsWith`\r\nTRUE                       | `True`, `IsTrue`\r\n\r\nIf no suffix is present to determine the operator by, it is assumed that the `IS` operator was intended.\r\n\r\n\r\n#### Data Functions\r\n\r\nData functions determine what should be done with a particular selection of entities before a result is returned. For instance,\r\nthe `count` data function just returns the collection size for a subset of data, thus allowing you to start your query method with\r\n`count` and expect it to return the size of the selection. Currently, the only other selected function is `delete`.\r\n\r\nBy extending the data functions, you are also extending the DSL for query methods by allowing various new data function names to be\r\nused in the beginning of a query method's name.\r\n\r\n#### Data Stores\r\n\r\nThis framework has an abstraction hiding away the details of where and how entities are stored and are looked up. The default\r\nbehavior is, of course, to keep everything in memory. It might, however, be necessary to delegate this to some external service\r\nor entity, such as an im-memory data store, a distributed cache, or an actual database.\r\n\r\nAll you have to do is implement the `com.mmnaseri.utils.spring.data.store.DataStore` interface and point it to the right direction.\r\n\r\n#### Result Adapters\r\n\r\nMany times the actual implementation methods for an operation return very generic results, such as a list or a set, whereas the\r\nrequired return type for the repository interface method might be something else. Suppose for instance, that the implementation\r\nmethod returns a List, while the interface method returns just one instance.\r\n\r\nIn such cases, it is necessary to adapt the results to the output format, and that is exactly what the result adapters are for.\r\n\r\nThey have a priority order which dictates in what order they will be executed.\r\n\r\n#### Custom Implementations and Type Mapping Context\r\n\r\nYou can map custom implementations to repository interfaces. To this end, a type mapping context exists which will let you bind\r\nparticular repository interface super types to custom implementation classes. The methods are then looked up according to their\r\nsignature.\r\n\r\nImplementations registered with a type mapping context are made available to all repository factory instances and are thus shared.\r\n\r\nWhen proxying a repository method this is the order with which a method is bound to an implementation:\r\n\r\n  1. We first look for custom implementations supplied directly to the factory while requesting a mock instance\r\n  2. We look at globally available implementations supplied through the configuration object\r\n  3. We try to interpret the method name as a query.\r\n\r\nBy default, the following type mappings are in place:\r\n\r\n  * All repositories can include any of the methods defined in `com.mmnaseri.utils.spring.data.commons.DefaultCrudRepository`\r\n  which implements the methods introduced in `org.springframework.data.repository.CrudRepository`.\r\n  * All repositories can include any of the methods defined in `com.mmnaseri.utils.spring.data.commons.DefaultPagingAndSortingRepository`\r\n  which adds paging and sorting capabilities to the repositories as per `org.springframework.data.repository.PagingAndSortingRepository`.\r\n  * If `org.springframework.data.jpa.repository.JpaRepository` is found in the classpath, all repositories will be able to have\r\n  methods from `com.mmnaseri.utils.spring.data.commons.DefaultJpaRepository` that are not already present in one of the above in\r\n  their repertoire.\r\n  * If `org.springframework.data.gemfire.repository.GemfireRepository` is present in the classpath, all repositories will be able to\r\n  include methods from this interface that are not present in the above in their list of methods and rest assured that an implementation\r\n  will be provided, courtesy of `com.mmnaseri.utils.spring.data.commons.DefaultGemfireRepository`.\r\n\r\n#### Event Listeners\r\n\r\nYou can register event listeners for each of the following events:\r\n\r\n  * `BeforeInsertDataStoreEvent`\r\n  * `AfterInsertDataStoreEvent`\r\n  * `BeforeUpdateDataStoreEvent`\r\n  * `AfterUpdateDataStoreEvent`\r\n  * `BeforeDeleteDataStoreEvent`\r\n  * `AfterDeleteDataStoreEvent`\r\n\r\nThe event handlers can then modify, take note of, or otherwise interact with the entities for which the event was raised.\r\n\r\nIf you use the `enableAuditing()` feature above, an event listener (`com.mmnaseri.utils.spring.data.store.impl.AuditDataEventListener`)\r\nwill be registered with the configuration which will enable auditing features and will set relevant properties in the appropriate\r\njuncture by listening closely to the events listed above.\r\n\r\n##### Auditing\r\n\r\nOut-of-the-box auditing is supported through this event mechanism for the usual `CreatedBy`, `CreatedDate`, `LastModifiedBy`,\r\nand `LastModifiedDate` audit annotations provided by Spring Data Commons. To support user-related auditing (created by and last\r\nmodified by) you will need to supply an `AuditorAware` or accept the default one, which will always return a String object with\r\nvalue, `\"User\"`.\r\n\r\nBy default, auditing is disabled. This is to follow in the footprints of Spring. Since Spring Data asks you to explicitly enable\r\nauditing, this framework, too, pushes for the same requirement.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}